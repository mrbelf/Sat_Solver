/**
 * This file should be placed at the node_modules sub-directory of the directory where you're 
 * executing it.
 * 
 * Written by Fernando Castor in November/2017. 
 */
exports.solve = function(fileName) {
  let formula = readFormula(fileName)
  let result = doSolve(formula.clauses, formula.variables)
  return result // two fields: isSat and satisfyingAssignment
}

// Receives the current assignment and produces the next one
// used binary addition for that.
function nextAssignment(currentAssignment) {
  let isOver = false;
  for (i = (currentAssignment.length-1); (!isOver) && (i >= 0); i--) {
    if (!currentAssignment[i]) {
      currentAssignment[i] = true;
      isOver++;
      } else {
        currentAssignment[i] = false;
          if (i == 0) {
            isOver++;
          }
      }
  }
  return currentAssignment;
}

function doSolve(clauses, assignment) {
  
  let numClauses = clauses.length;
  let numVar = assignment.length;
  let isSat = false;
  let orClauses = false;
  let contador = 0;
  let maxTests = 2**assignment.length; // created variable for not doing the maths every time.
  let clausesClone = Array.from(clauses);
  let nextAssignmentArray = Array.from(assignment);
  nextAssignmentArray = nextAssignment(nextAssignmentArray);
  for(let m = 0; m < numClauses;m++){
    clausesClone[m] = Array.from(assignment);
  }

  for(let n = 0;n<numClauses;n++){
    for(let o = 0;o<numVar;o++){
      clausesClone[n][o] = 'a';
    }
  }

  let clausesVariables;
    for(let n = 0;n<numVar;n++){
      clausesVariables = n+1;
      for(let o = 0;o<numClauses;o++){
        for(let p = 0;p<clauses[o].length;p++){
          if(clauses[o][p].abs = clausesVariables){
            if(clauses[o][p]>0){
              clausesClone[o][n] = true;
            }else{
              clausesClone[o][n] = false;
            }
          }
        }
      }
    }
 


  // runs while isn't sat or isn't the last test.
  while ((!isSat) && contador < maxTests) {
    isSat = true;

    // run through all elements of the clauses array comparing them to the assignments array
    // if some variable is already true it stops
    // if some clause is already false it stops
    for(let n = 0;(n<numClauses)&&(isSat);n++){
      orClauses = false;
      for(let o = 0;(o<numVar)&&(!orClauses);o++){
        if(clausesClone[o]!='a'){
          if(clausesClone){
            orClauses = true;
          }
        }
      }
      if(!orClauses){
        isSat = false;
        assignment = nextAssignment(assignment);
        nextAssignmentArray = nextAssignment(nextAssignmentArray);
      }
    }
    
    for(let m = 0;m<assignment;m++){
      if(assignment[n]!=nextAssignmentArray[n]){
        for(let n = 0;n<clauses;n++){
          if(clausesClone[m][n] != 'a'){
            clausesClone[m][n] = !clausesClone[m][n];
          }
        }
      }
    }

    // does this assignment satisfy the formula? If so, make isSat true.
    contador++;
  }

  // returns if is sat and the assignment that solves it (if any).
  let result = {'isSat': isSat, satisfyingAssignment: null}
  if (isSat) {
    for (let i = 0; i < assignment.length; i++) {
      if (assignment[i] == true) {
        assignment[i] = 1;
      }
    }
    result.satisfyingAssignment = assignment
  }
  return result
}
  
function readFormula(fileName) {
  let fs = require("fs");
  let text  = fs.readFileSync('./Examples/' + fileName, "utf8").split('\r\n'); //  an array containing lines of text extracted from the file. 
  let clauses = readClauses(text)
  let variables = readVariables(clauses)
  
  // check if problem is in the correct form.
  let specOk = checkProblemSpecification(text, clauses, variables)

  // creates a result with clauses and variables of the file read.
  let result = { 'clauses': [], 'variables': [] }
  if (specOk) {
    result.clauses = clauses
    result.variables = variables
  }
  return result
}

function readClauses(text) {
  let arrClauses = [];

  for (let i = 0; i < text.length; i++) {

    //get the lines that don't start with 'p' or 'c' or that are not blank.
    if (!(text[i].startsWith('c') || text[i].startsWith('p') || text[i].length == 0)) {
      let integers = [];
      integers = text[i].match(/[+-]?\d+(?:\d+)?/g); //read just the integers (regex in <https://regexr.com/>)

      // merge the lines that are split.
      while (integers[integers.length - 1] != 0) {
        integers = integers.concat(text[i+1].match(/[+-]?\d+(?:\d+)?/g)); 
        i++;
      }

      //removes the 0's from the end of the arrays.
      integers.splice(integers.length - 1);
      arrClauses.push(integers); 
    }
  }
  return arrClauses;
}

function readVariables(clauses) {
  let variables = [];
  let maxValue = 0;

  // see what is the biggest variable.
  for (let i = 0; i < clauses.length; i++) {
    for (let j = 0; j < clauses[i].length; j++) {
      if (Math.abs(clauses[i][j]) > maxValue) {
        maxValue = Math.abs(clauses[i][j]);
      }
    }
  }

  // set all variables as 0.
  for (let i = 0; i < maxValue; i++) {
    variables[i] = 0;
  }

  return variables;
}

function checkProblemSpecification(text, clauses, variables) {
  let problem = [];
  let numberClauses = 0;
  let numberVariables = 0;

  for (let i = 0; i < text.length; i++) {
    if (text[i].startsWith('p')) { 
      //crates an array with the words in the 'p' line.
      problem = text[i].match(/[+-]?\d+(?:\d+)?/g);

      //get the last 2 values of the array (numb of Variables and numb of Clauses).
      numberVariables = problem[problem.length - 2];
      numberClauses = problem[problem.length - 1];
    }
  }

  // divided the solution for easy understanding.
  let checkVariables = (numberVariables == variables.length);
  let checkClauses = (numberClauses == clauses.length);

  return (checkVariables && checkClauses);
}
