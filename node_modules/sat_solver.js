/**
 * This file should be placed at the node_modules sub-directory of the directory where you're 
 * executing it.
 * 
 * Written by Fernando Castor in November/2017. 
 */
exports.solve = function(fileName) {
  let formula = readFormula(fileName)
  let result = doSolve(formula.clauses, formula.variables)
  return result // two fields: isSat and satisfyingAssignment
}

// Receives the current assignment and produces the next one
// used binary addition for that.
function nextAssignment(currentAssignment) {
  let isOver = false;
  for (i = (currentAssignment.length-1); (!isOver) && (i >= 0); i--) {
    if (!currentAssignment[i]) {
      currentAssignment[i] = true;
      isOver++;
      } else {
        currentAssignment[i] = false;
          if (i == 0) {
            isOver++;
          }
      }
  }
  return currentAssignment;
}

function doSolve(clauses, assignment) {
  let isSat = false
  let contador = 0;
  let maxTests = 2**assignment.length; //created variable for not doing the maths every time.
  let andClauses;
  let orClauses;

  // runs while isn't sat or isn't the last test.
  while ((!isSat) && contador < maxTests) {
    andClauses = true;

    // run through all elements of the clauses array comparing them to the assignments array
    // if some variable is already true it stops
    // if some clause is already false it stops
    for (let j = 0; j < clauses.length && andClauses; j++) {
      orClauses = false;
      for(i = 0; i < assignment.length && !orClauses; i++){
        for (let k = 0; k < clauses[j].length; k++) {
          if (clauses[j][k] == i+1) {
            orClauses = orClauses || assignment[i];
          } else if (clauses[j][k] == -(i+1)) {
            orClauses = orClauses || !assignment[i];
          }
        }
      }
      andClauses = andClauses && orClauses;
    }
    
    // does this assignment satisfy the formula? If so, make isSat true.
    if (andClauses) {
      isSat = true;
    } else {
      // if not, get the next assignment and try again. 
      assignment = nextAssignment(assignment)
    }
    contador++;
  }

  // returns if is sat and the assignment that solves it (if any).
  let result = {'isSat': isSat, satisfyingAssignment: null}
  if (isSat) {
    result.satisfyingAssignment = assignment
  }
  return result
}
  
function readFormula(fileName) {
  let fs = require("fs");
  let text  = fs.readFileSync('./Examples/' + fileName, "utf8").split('\r\n'); //  an array containing lines of text extracted from the file. 
  let clauses = readClauses(text)
  let variables = readVariables(clauses)
  
  // check if problem is in the correct form.
  let specOk = checkProblemSpecification(text, clauses, variables)

  // creates a result with clauses and variables of the file read.
  let result = { 'clauses': [], 'variables': [] }
  if (specOk) {
    result.clauses = clauses
    result.variables = variables
  }
  return result
}

function readClauses(text) {
  let arrClauses = [];

  for (let i = 0; i < text.length; i++) {

    //get the lines that don't start with 'p' or 'c' or that are not blank.
    if (!(text[i].startsWith('c') || text[i].startsWith('p') || text[i].length == 0)) {
      let integers = [];
      integers = text[i].match(/[+-]?\d+(?:\d+)?/g); //read just the integers (regex in <https://regexr.com/>)

      // merge the lines that are split.
      while (integers[integers.length - 1] != 0) {
        integers = integers.concat(text[i+1].match(/[+-]?\d+(?:\d+)?/g)); 
        i++;
      }

      //removes the 0's from the end of the arrays.
      integers.splice(integers.length - 1);
      arrClauses.push(integers); 
    }
  }
  return arrClauses;
}

function readVariables(clauses) {
  let variables = [];
  let maxValue = 0;

  // see what is the biggest variable.
  for (let i = 0; i < clauses.length; i++) {
    for (let j = 0; j < clauses[i].length; j++) {
      if (Math.abs(clauses[i][j]) > maxValue) {
        maxValue = Math.abs(clauses[i][j]);
      }
    }
  }

  // set all variables as 0.
  for (let i = 0; i < maxValue; i++) {
    variables[i] = 0;
  }

  return variables;
}

function checkProblemSpecification(text, clauses, variables) {
  let problem = [];
  let numberClauses = 0;
  let numberVariables = 0;

  for (let i = 0; i < text.length; i++) {
    if (text[i].startsWith('p')) { 
      //crates an array with the words in the 'p' line.
      problem = text[i].match(/[+-]?\d+(?:\d+)?/g);

      //get the last 2 values of the array (numb of Variables and numb of Clauses).
      numberVariables = problem[problem.length - 2];
      numberClauses = problem[problem.length - 1];
    }
  }

  // divided the solution for easy understanding.
  let checkVariables = (numberVariables == variables.length);
  let checkClauses = (numberClauses == clauses.length);

  return (checkVariables && checkClauses);
}
